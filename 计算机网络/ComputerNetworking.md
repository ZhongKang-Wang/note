# 20250804

## 套接字编程基础

### 两种网络程序的架构



1. B/S架构 Browser/Server 浏览器/服务器
2. C/S结构 Client/Server 客户机/服务器
   - 客户机和服务器是指两个通过网络连接的进程



基于套接字的网络编程，通常使用C/S架构。



### 套接字类型

在Linux系统中，有3种套接字类型

1. 流套接字，基于TCP
2. 数据包套接字，基于UDP
3. 原始套接字：可以读写内核没有处理的IP数据包





# 20250801

## TCP 套接字编程

服务器

1. 创建服务器端套接字‘
2. 绑定套接字到一个IP地址和一个端口
3. 将套接字设置为监听模式，等待连接请求
4. 接收连接请求，并返回一个新的套接字
5. 用新的套接字和客户端进行通信
6. 继续监听，等待其他连接
7. 关闭监听套接字，退出服务器端



客户端

1. 创建套接字
2. 发出请求
3. 和服务端通信
4. 关闭程序



# 20250806

----

Q：在网页访问场景中，服务器在启动时已经绑定一个地址（IP地址+端口号)，客户端可以通过该地址建立连接，那么为什么服务器还要再生成一个新的连接地址呢？

A：核心原因是**功能分离与并发处理的需求**—— 服务器需要同时接收新连接和处理已有连接，两者不能共用同一个 “通道”。

- 服务器的 “监听套接字”：专门负责 “接新活”

服务器启动时，会创建一个**监听套接字（Listen Socket）**，并绑定到固定的 `IP:端口`（比如 HTTP 的 80、HTTPS 的 443）。
这个套接字的唯一作用是：**被动等待客户端的连接请求**（即 TCP 三次握手的发起），它不处理任何实际的数据传输（比如不发送网页 HTML、不接收用户表单数据）。

> 举个例子：监听套接字就像公司的 “前台”，只负责 “接听电话”（接收连接请求），但不负责 “处理业务”（传输数据）。

- 连接套接字：专门负责 “干具体活”

当客户端（浏览器）发起连接请求（比如输入网址后，浏览器调用 `connect()` 向服务器的 80 端口发请求），服务器的监听套接字会通过 `accept()` 函数 “接受” 这个连接。

此时，服务器会**创建一个新的连接套接字（Connection Socket）**，专门用于和这个客户端进行数据传输（发送网页内容、接收用户操作等）。

这个连接套接字的特点是：

1. 仍然使用服务器的**原始 IP 和端口**（比如 80）作为 “自身标识”（在 TCP 四元组中，服务器的 IP 和端口不变）；
2. 它的唯一任务是**处理与特定客户端的双向数据通信**，不参与接收新连接。

> 类比：连接套接字就像公司的 “业务专员”，前台（监听套接字）接到电话后，会分配一个专员（连接套接字）专门对接这个客户，处理具体需求。



Q：为什么必须 “新生成一个”？

如果服务器不创建新的连接套接字，而是用监听套接字直接处理数据，会导致一个严重问题：**监听套接字会被 “占用”，无法接收新连接**。

比如：

- 假设服务器用监听套接字给第一个客户端传输一个大网页（需要 10 秒），在这 10 秒内，监听套接字正忙着发数据，无法再接收第二个客户端的连接请求 —— 这意味着新用户打开网页会一直卡住，直到第一个用户的传输完成。

而通过 “监听套接字负责接新连接，连接套接字负责处理数据” 的设计，就能实现：

- 监听套接字永远 “空闲”，随时可以接收新用户的连接请求；
- 每个已连接的客户端由独立的连接套接字处理，互不干扰（即使一个客户端传输数据很慢，也不影响其他客户端）。



需要明确的是：**服务器不会为新连接生成新的 IP 和端口**。


总结一下：服务端在监听到有新的连接之后会生成新的`连接套接字`，这个连接套接字使用的仍然是服务器最初绑定的 IP 和端口，而客户端，举个例子，当客户端上的浏览器发起连接时，系统临时为其分配的12345 端口，每次分配的端口可能不一样







网络编程中的两种I/O处理模式

- 阻塞套接字：如果调用不能完成，就让线程立刻进入阻塞状态
- 非阻塞套接字：立刻返回错误码
