# 20250701

Q：进程与程序的区别？

程序：是指令的集合，是静态的；

进程：是程序在处理机上的一次执行过程，动态地产生、执行，然后消亡。

- 一个程序可以由多个进程组成
- 进程具有
  - 独立性：进程是一个相对完整的资源分配单位
  - 异步性：每个进程按照各自独立的、不可预知的速度向前推进。





# 2.1 CPU是如何执行程序的

Question

1. a = 1 + 2 这条代码是怎么被CPU执行的？

2. 32位和64位软件的区别？
   - 32位的操作系统可以运行在64位的电脑上吗？
   - 64位的操作系统可以运行在32位的电脑上吗？
   -  如果不行，原因是什么？

3. 64位相比32位CPU的优势在哪？
4. 64位CPU的计算性能一定比32位CPU高很多吗？



## 图灵机的工作方式

1. 读取纸带格子上的内容
2. 控制单元区分是数字还是运算符指令。如果是数字，先存起来；如果是指令，便吩咐运算单元读取事先存入的状态进行运算
3. 最后将运算的结果写入纸带格子上



## 冯诺依曼模型

冯诺依曼模型

|                |                    |
| -------------- | ------------------ |
| 控制器、运算器 | 集成在中央处理器中 |
| 存储器         | 内存               |
| 输入/输出设备  | 键盘/显示器        |

## 中央处理器

Central Processing Unit，CPU

32位和64位的CPU主要区别在于

- 32位的CPU一次可以计算4个字节
- 64位的CPU一次可以计算8个字节

CPU的位宽：CPU可以一次运算的数据量。如果是8位的CPU，一次只能计算0~255范围内的数值。



Q：为什么有了内存还需要寄存器？
原因是内存离CPU太远了，而寄存器就在CPU中，还紧挨着控制单元和逻辑运算单元，计算速度会更快。



64位CPU性能不一定比32位CPU高很多。

原因是很少应用需要计算超过32位的数字。只有计算超过32位的数字，64位的优势才能体现出来。



指令周期：CPU从程序计数器（存储的是指令的内存地址）中读取指令、到执行的这个过程称为CPU的指令周期。

 

GHz，1G表示1s产生1G次脉冲信号，时钟周期是1/1G。一个高低电平就是一个时钟周期。

 

一个程序的CPU执行时间 = CPU时钟周期数 * 时钟周期时间

 

要想CPU跑得更快，可以提升主频。但是当性能达到瓶颈时，我们也可以减少程序所需的时钟周期数。

 时钟周期数 = 指令数 * 每条指令的平均时钟周期



想要程序跑得快，可以优化

- 指令数：靠编译器



# 2.2 磁盘与内存

内存：断电后数据丢失

硬盘：断电后不会丢失

## 存储器的层次结构

|                                  |                         |
| -------------------------------- | ----------------------- |
| 大脑正在思考的东西               | CPU中的寄存器           |
| 大脑中的记忆                     | CPU Cache， CPU高速缓存 |
| L1 Cache 分为 数据缓存和指令缓存 | 短期记忆                |
| L2/L3 Cache                      | 长期记忆                |
| 内存                             | 桌子上的书              |
| 硬盘                             | 图书馆里的书            |

注：绝大多数设计中，每个核心都有专属于自己的L1 Cache和L2 Cache，而L3 Cache是多个CPU共享的。那么势必会存在读写不一致的问题，如何解决呢？

 

CPU Cache 用的是SRAM（static random Access Memory，静态随机存储器），断电则数据丢失。

内存用的是DRAM，动态随机存取寄存器，只需要一个晶体管和一个电容就能存储数据。因为数据被存储在电容中，而电容会漏电，因此需要定时刷新电容。

 

SSD 固态硬盘

HDD 机械硬盘

 

# 2.3 如何写出让CPU跑得更快的代码

 

## CPU Cache的数据结构和读取过程

 

CPU Cache是由很多个Cache行组成的，是CPU从内存读取数据的基本单位

Cache Line由标志位 + 数据块构成

 

如果CPU所要操作的数据在CPU Cache中，意味着缓存命中。缓存命中越高，代码的性能就越好。

 要想提升数据的缓存命中率，就按照内存布局顺序访问。

 

### CPU的分支预测器

 

如果分支预测可以预测到是执行`if`中的指令还是`else`中的指令，就可以提前把这些指令放到指令缓存中。这样CPU可以直接从Cache中读取指令，执行速度就会加快。

 

C/C++分支预测优化的宏

`__builtin_expect`(GCC内置函数，提示编译器某条分支更可能执行)

 

 

C/C++编译器提供了`likely`和`unlikely`两种宏

宏定义

```c++
#define likely(x) __builtin_expect(!!(x), 1)
// !!(x)：将表达式转化为布尔值，告诉编译器x为真的概率很高
#define unlikely(x) __builtin_expect(!!(x), 0)
if (likely(a == 1)) {
	// do somthing...
} else {
	// do somthing...
}
```



如何提升多核CPU的缓存命中率？

 

如果一个线程都在同一个核心上执行，那么L1和L2 Cache的缓存命中率也会显著提高。

 
