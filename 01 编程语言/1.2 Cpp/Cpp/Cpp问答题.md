# 2025-10-10

Q1:定义一个空的类型，里面没有任何成员变量和成员函数。对该类求`sizeof`，为什么得到的结果是1？
A1:
`sizeof` 一个空类是 1，是因为：

C++要求每个对象必须有唯一的内存地址，如果大小为 0，就无法保证这一点。

通常为了满足这个要求，编译器会自动插入一个占位字节，这是C++为“存在”本身付出的最小代价。



Q1.2:那么为什么在该类型中添加一个构造函数和析构函数，再对该类型求`sizeof`，还是1呢？

A1.2:调用构造函数和析构函数只需要知道函数的地址即可。而这些函数的地址只与类型相关，而与类型的实例无关，因此编译器也不会因为两个函数而在实例内添加任何额外的信息。



Q1.3:如果把析构函数标记为虚函数呢？

C++的编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针。在32位的机器上，一个指针占4个字节，因此`sizeof`的结果是4；类似地，在64位的机器上，`sizeof`的结果是8。



《深度探索C++对象模型》



# 2025-10-12

Q2：关于`sort`排序，底层如何？

`sort`的底层是一种混合排序策略。

在数据量比较大，递归深度比较高的情况下会先采用**快速排序**，时间复杂度一半是$O(nlogn)$，因为快排最差的时间复杂度是$O(n^2)$，所以为了避免这种情况，会在适当的时候（depth_limit = log2(last - first) * 2, depth_limit减小到0)改用**堆排序**，最后才会再用插入排序。

当然，数据量较小的情况下是直接用**插入排序**的。



这也很容易理解，快排的局部性更好，所以优先用快排处理较大的数据；又考虑到快排的最差情况，所以用堆排；最后尽管插入排序的时间复杂度是$O(n^2)$，数据量较小的情况下，插入排序通常更快。



时间复杂度:$O(nlogn)$

空间复杂度:$O(logn)$ （快排的递归栈开销）



# Q3：智能指针底层是怎么样的？





# 2025-10-25

Q4：cpp为什么有了数组和vector，还需要array呢？

（原生）数组的缺陷：

1. 无边界检查：访问越界时未定义行为
2. 隐式退化：作为函数参数时会退化成指针
3. 功能薄弱：获取长度信息还需要依赖全局函数，如`sizeof`

C++11引入的array是封装了固定大小数组的模板类，解决了上述问题：

1. 支持边界检查：如at()成员函数越界访问会抛出异常
2. 作为参数传递时不会发生隐式转换
3. 不仅提供size()等成员函数，而且还支持STL算法



至于`vector`，虽然大小可动态调整，但代价是内存分配在堆上，大小变化时可能存在内存重分配和拷贝，需要一定的开销；而array通常分配在栈上，保留了原生数组性能。
