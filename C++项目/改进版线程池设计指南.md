# C++ 线程池项目建设指南

这是一个面向学习和实践的「自定义线程池项目」建设指南，适合有 C++ 基础并希望深入了解 Linux 多线程、实时系统等同步/异步矩阵编程的学生。

本项目分步进行，提出问题，提示方向，不直接给答案，而是帮助你建立设计思维和规范。

## 项目初始版：最简单的线程池

**目标：**

- 

**思考问题：**

1. 你是否懂得为什么需要 `static` 成员？
2. 你的线程执行任务后是否继续工作？远程怎么做？
3. 如果多个线程抽同一个任务会怎样？

**拟建思路：**

- 使用 `pthread_create` 和 `pthread_join`
- 使用 `pthread_mutex_t` 和 `pthread_cond_t` 做同步
- 使用 `vector<CTask*>` 做任务队列

## 阶段 1：任务实例化 + 内存管理

**目标：**

- 

**思考问题：**

1. `CTask` 是否需要虚拟构造/虚拟析构？
2. 任务完成后怎样 `delete` ？是否能管理定式生命呢？
3. 怎么用 `std::function` + 模板来进行抽象？

**拟建思路：**

- 考虑把 `CTask` 转为完全抽象的功能对象
- 任务提交时 new 一个对象，执行完后 delete
- 后期考虑用 smart pointer

## 阶段 2：支持返回值

**目标：**

- 

**思考问题：**

1. `std::packaged_task` 是什么？
2. `std::future`/、`std::promise`怎么与线程合作？

**提示思路：**

- 用模板函数接收 any 任务
- 给任务打包 packaged_task 后转换为 std::function<void()> 加入队列
- 返回 future 给用户

## 阶段 3：加入线程管理

**目标：**

- 

**思考问题：**

1. 如果线程数 > CPU core 会怎样？
2. 如果任务推入时没有空闲线程，怎么做？

**提示思路：**

- 使用计数器 busyCount/idleCount
- 给系统上报状态，便于采集和调试

## 阶段 4：加入队列管控

**目标：**

- 

**思考问题：**

1. 如果有上百个线程同时 submit 怎么确保有效性？
2. 如果进程占满队列，怎样做是最优的？

**提示思路：**

- 加上队列长度管控，达到上限开始 reject/急缓/等待
- 可以设计 reject handler

## 阶段 5：自动销毁/先后级编程

**目标：**

- 

**思考问题：**

1. 如果有任务长时阻塞，其他线程如何出发 shutdown?
2. 如果线程已经处于 `cond_wait` ，怎样退出？

**提示思路：**

- 线程闲置时可定时检查 idle_time
- 线程检测 shutdown flag + cond.broadcast 可通知线程退出

## 最后：方向和综合

**可考虑扩展方向：**

- 支持定时任务
- 支持指定任务后续
- 支持 CPU 添加/扣减后自动调整线程数
- 用 epoll 重构任务处理 IO 垂线化