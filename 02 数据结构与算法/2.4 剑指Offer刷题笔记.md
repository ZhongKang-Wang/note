# 1

# 2

# 3.1 数组中重复的数字

**2025-10-10**

方法1：排序。找到重复的数只需要从前往后遍历。时间复杂度:$O(nlogn)$

方法2：哈希表。遍历数组，用哈希表记录遍历过的元素。时间复杂度:$O(n)$，空间复杂度:$O(n)$

方法3：**所有数字都在0~n-1的范围内**，如果数组中没有重复的数字，那么对数组进行排序后数字i应该出现在下标为i的位置上。

```c++
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            if (nums[i] < 0 || nums[i] >= n) {
                return -1;
            }
        }
        for (int i = 0; i < n; ++i) {
            while (nums[i] != i) {
                if (nums[i] == nums[nums[i]]) { // 有重复元素
                    return nums[i];
                } else {
                    swap(nums[i], nums[nums[i]]);
                }
            }
        }
        return -1;
    }
};
```

Q1:为什么`while`不会死循环？

数组中要么有重复的元素，要么没有重复的元素。

如果没有重复的元素，例如[1, 0]，每次交换都会让1个元素归位，循环会结束；

如果有重复的元素，例如[1, 1]，会直接return

时间复杂度:$O(n)$

空间复杂度:$O(1)$



# 3.2 不修改数组找出重复的数

**2025-10-13**

思考：要求不能修改输入的数组，方法一和方法三可以拷贝一个临时的数组，但是如果希望空间复杂度是$O(1)$的呢？



题目要求在一个长度为$n+1$的数组里的所有数字都在1~n的范围内，所以至少有1个数是重复的。

我们把1~n从中对半分，分为[1, m]和[m + 1， n]，如果[1, m]的个数$>m$，说明这其中有重复的元素。

持续二分。



二分查找，以左闭右闭区间为例

```c++
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n = nums.size();
        int left = 1, right = n - 1; // 数字范围 1~n-1

        while (left <= right) {
            int m = left + (right - left) / 2;
            int cnt = 0;
            for (int x : nums) {
                if (x >= left && x <= m) {
                    ++cnt;
                }
                if (cnt > (m - left + 1)) {
                    break;
                }
            }
            if (cnt > (m - left + 1)) {
                right = m - 1;
            } else {
                left = m + 1;
            }
        }
        return left; // left就是重复数字
    }
};

```

时间复杂度：$O(nlogn)$

空间复杂度：$O(1)$

注意：

1. 左闭右闭区间的长度。如$[1, 2, 3]$，$len = 3 - 1 + 1 = 3$。也即 $len = right - left + 1$

2. 为什么当 $cnt > m - left + 1$ 之后 $right = m - 1$ ？

   从直觉上来看，区间被 $m$ 划分为 $[left, m]$ 和 $[m + 1, right]$，那么如果 $cnt > m - left + 1$，$right$ 右端点应该收缩到 $m$ 才对。但是这样是不对的。例如 $[1, 1]$的话，$left$ 指向 0 时，$right$ 也指向 0 时，$m = 0$，接着 $cnt$ 计算 1的个数，就会触发 $right = m$，就变成死循环了。

   因此，在**左闭右闭区间**中，无论是 $left$ 还是 $right$ 都要变，进而收缩 [$left$, $right$] 合法区间。

   那么这里为什么 $right = m - 1$ 一定是对的呢？

   - 如果 m 是重复的元素，那么在 [left, m - 1]中一定还有m，所以没问题；
   - 如果 m 不是重复的元素，那么 [left, m - 1]中一定还存在着重复的元素，所以也没问题；

   综上，收缩 $right$，重复的元素仍然在合法的区间中。

3. 最后，为什么返回值是 $left$ ？

   每次迭代结束后，重复元素一定在 $[left, right]$ 中。

   而当整个循环结束后，$left = right + 1$。此时的合法区间是 $[right + 1, left]$。

   因此，重复的数字便是 $left$。



该算法只能找出一个重复的元素，那么如果要让你找出数组中所有重复的元素应该如何做呢？

$Leecode$ 442 数据中重复的元素



# 4 二维数组中的二分查找

// 从左下角开始查找，当然，从右上角查找也是可以的。

```c++
class Solution {
public:
    bool searchArray(vector<vector<int>> array, int target) {
        if (array.empty()) 
            return false;
        int rows = array.size(), columns = array[0].size();
        int row = array.size() - 1, column = 0;
        bool found = false;
        while (row >= 0 && column < columns) {
            if (array[row][column] == target) {
                found = true;
                break;
            } else if (array[row][column] < target) {
                ++column;
            } else if (array[row][column] > target) {
                --row;
            }
        }
        return found;
        
    }
};
```



# 5 替换空格

```c++
class Solution {
public:
    string replaceSpaces(string &str) {
        int n = str.size();
        string res {};
        for (int i = 0; i < n; ++i) {
            if (str[i] == ' ') {
                res += "%20";
            } else {
                res += str[i];
            }
        }
        return res; // o(n) o(n)
    }
};
```

时间复杂度：$O(n)$

空间复杂度：$O(n)$



正确做法：在原来的字符串上进行双指针

先计算空格的个数，得到新的字符串长度，然后从后往前遍历。其实这个方法是挺好的，就是我咋感觉它这个代码不太简介，尽管变量名见名知意。

```c++
class Solution {
public:
    string replaceSpaces(string &str) {
        int n = str.size();
        // 1. 计算空格的个数
        int numberOfBlank = 0;
        for (int i = 0; i < n; ++i) {
            if (str[i] == ' ') {
                ++numberOfBlank;
            }
        }
        // 2. 得到扩展之后字符串的长度
        int newLength = n + 2 * numberOfBlank;
        str.resize(newLength);
        // 3. 双指针
        int indexOfOriginal = n - 1, indexOfNew = newLength - 1;
        while (indexOfOriginal != indexOfNew) {
            if (str[indexOfOriginal] == ' ') {
                str[indexOfNew--] = '0';
                str[indexOfNew--] = '2';
                str[indexOfNew--] = '%';
            } else {
                str[indexOfNew--] = str[indexOfOriginal];
            }
            --indexOfOriginal;
        }
        return str;
    }
};
```



# 6 链表：从尾到头打印链表

定义一个链表结构体

```c++
struct ListNode {
    int m_nValue;
    ListNode* pNext;
};
```

不修改原结构，用栈；修改原结构，就相当于反转链表



如果用栈实现的话，我们应该联想到**递归**，因为递归本身也是一个栈结构。

注意：与栈相比，如果链表长度很长，会导致栈溢出。



# 关于树的一些问题

前序遍历

中序遍历

后序遍历

递归 + 迭代，拢共6种实现方法，要搞清楚（**DFS，Depth-First Search**)

## 前序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void traversal(TreeNode* root, vector<int>& res) {
        if (root == nullptr) {
            return;
        }
        res.push_back(root->val);
        traversal(root->left, res);
        traversal(root->right, res);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root, res);
        return res;
    }
};
```

## 

## 迭代做法

### 前序遍历

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if (root == nullptr) {
            return {};
        }
        vector<int> res;
        stack<TreeNode*> st;
        st.push(root);
        while (!st.empty()) {
            TreeNode* pNode = st.top();
            st.pop();
            res.push_back(pNode->val);
            if (pNode->right != nullptr) {
                st.push(pNode->right);
            }
            if (pNode->left != nullptr) {
                st.push(pNode->left);
            }
        }
        return res;
    }
};
```



### 中序遍历

```c++
// 左根右
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if (root == nullptr) {
            return {};
        }
        vector<int> res;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != nullptr || !st.empty()) {
            if (cur != nullptr) {
                st.push(cur);
                cur = cur->left;
            } else {
                cur = st.top();
                st.pop();
                res.push_back(cur->val);
                cur = cur->right;
            }
        }
        return res;

    }
};
```



### 后序遍历

左右根，和根左右类似，

```c++
// 根右左 先压左子树，再压右子树
// 反转数组
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        if (root == nullptr) {
            return {};
        }
        stack<TreeNode*> st;
        st.push(root);
        vector<int> res;
        while (!st.empty()) {
            TreeNode* pNode = st.top();
            st.pop();
            res.push_back(pNode->val);
            if (pNode->left != nullptr) {
                st.push(pNode->left);
            }
            if (pNode->right != nullptr) {
                st.push(pNode->right);
            }
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```



### 层序遍历，广度优先遍历**BFS，Breadth-First Search**

队列

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if (root == nullptr) {
            return {};
        }
        vector<vector<int> > res;
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> temp;
            for (int i = 0; i < size; ++i) {
                TreeNode* pNode = que.front();
                que.pop();
                temp.push_back(pNode->val);
                if (pNode->left != nullptr) {
                    que.push(pNode->left);
                }
                if (pNode->right != nullptr) {
                    que.push(pNode->right);
                }
            }
            res.push_back(temp);
        }
        return res;
    }
};
```





堆（最大堆 和 最小堆） 和 红黑树



# 7 重建二叉树

二叉树节点的定义

```c++
struct BinaryTreeNode {
    int m_nVaue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
}
```

# 8 二叉树的下一个节点

分析：对于一棵二叉树，要找出其中序遍历的下一个节点。

如果当前节点有右子树，那么它的下一个节点就是从右子树的父节点出发，一直`dfs`找到最深的左子节点；

如果当前节点没有右子树，

- 如果它是某个父节点的左子节点，那么它的下一个节点就是该父节点；

```plaintext
	爸爸
   /
我（没有右子树）
```

- 如果它是某个父节点的右子节点，那么就需要沿着父节点回溯，直到找到一个是它**父节点的左子节点的节点**。如果这样的节点存在，那么下一个节点就是父节点。

```plaintext
    爷爷
   /
爸爸
   \
   我（没有右子树）
```

综上所述，如果没有右子树，那么就是**找第一个把当前节点包含在左子树的祖先**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode *father;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* p) {
        if (p == nullptr) {
            return nullptr;
        }
        TreeNode* nextNode = nullptr;
        if (p->right != nullptr) { // 如果有右子树
            TreeNode* pRight = p->right;
            while (pRight->left != nullptr) {
                pRight = pRight->left;
            }
            nextNode = pRight;
        } else if (p->father != nullptr) { // 如果没有右子树
            TreeNode* pCurrent = p;
            TreeNode* pFather = p->father;
            while (pFather != nullptr && pFather->right == pCurrent) {
                pCurrent = pFather;  // 若当前节点是父节点的右子节点，继续向上
                pFather = pCurrent->father;
            }
            nextNode = pFather; // 退出循环时，father要么是nullptr，要么pCurrent == father->left
        }
        return nextNode;
        
    }
};
```

# 9 用两个栈实现队列

核心思路：一个栈作为输入栈，一个栈作为输出栈。



相关题目：用两个队列实现栈

解题思路：用两个队列模拟栈时，始终保持一个队列为空。另一个队列存储所有元素

当需要弹出元素（栈顶）时，只需操作非空队列即可



# 二分查找

# 归并排序

# 快速排序

```c++
#include <iostream>
#include <vector>
#include <stdexcept>
#include <ctime>
int Partition(std::vector<int>& vec, int start, int end);
void QuickSort(std::vector<int>& vec, int start, int end); 
int main() {
    std::vector<int> vec;
    int n = 0;
    // 输入数据
    std::cin >> n;
    int x = 0;
    for (int i = 0; i < n; ++i) {
        std::cin >> x;
        vec.push_back(x);
    }
    // 排序
    srand((unsigned int)time(nullptr));
    QuickSort(vec, 0, n - 1);
    for (int i = 0; i < n; ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << std::endl;
    return 0;
}


int Partition(std::vector<int>& vec, int start, int end) { // 左闭右闭
    if (start < 0 || end >= vec.size()) {
        throw std::runtime_error("Invalid parameters");
    }
    int index = start + rand() % (end - start + 1); // start + [0, end - start]
    std::swap(vec[start], vec[index]);
    int pivot = vec[start]; 
    int i = start, j = end;
    while (i < j) {
        while (i < j && vec[j] >= pivot) {
            --j;
        }
        while (i < j && vec[i] <= pivot) {
            ++i;
        }
        std::swap(vec[i], vec[j]);
    }
    std::swap(vec[start], vec[i]);
    return i;
}
void QuickSort(std::vector<int>& vec, int start, int end) {
    if (start >= end) {
        return;
    }
    int index = Partition(vec, start, end);
    QuickSort(vec, start, index - 1);
    QuickSort(vec, index + 1, end);
}
```





# 10 斐波那契数列

相关题目：青蛙跳台阶问题



一只青蛙可以跳1级，跳2级，...可以跳n级，那跳上n级的做法有多少种？

通过递推分析：

假设跳上第 `n` 级台阶的方法数为 `f(n)`。

- 当青蛙**最后一步跳 1 级**时，说明之前已经跳上了第 `n-1` 级，此时方法数为 `f(n-1)`；
- 当青蛙**最后一步跳 2 级**时，说明之前已经跳上了第 `n-2` 级，此时方法数为 `f(n-2)`；
- ...
- 当青蛙**最后一步直接跳 n 级**时，这是 1 种独立的方法。

因此，递推公式为：`f(n) = f(n-1) + f(n-2) + ... + f(1) + 1`（其中 `1` 对应直接跳 n 级的情况）

- 当 `n=1` 时，`f(1)=1`（只能跳 1 级）；
- 当 `n=2` 时，`f(2)=f(1)+1=2`（跳 1+1 级 或 直接跳 2 级）；
- 当 `n=3` 时，`f(3)=f(2)+f(1)+1=4`；
- 以此类推，可发现 `f(n) = 2^(n-1)`。

**结论**：跳上 n 级台阶的方法数为 `2^(n-1)`





# 11 旋转数组的最小数组

关于旋转排序数组。

二分查找。

如果数组中不包含重复元素，很容易写出如下代码

- [x] 153 搜索旋转排序数组中的最小值，无相同元素 这个是最好做的

```c++
int n = nums.size();
int left = 0, right = n - 1;
while (left <= right) {
    int mid = left + (right - left) / 2;
    if (nums[mid] > nums[n - 1]) {
        left = mid + 1;
    } else {
        right = mid - 1;
    }
}
return nums[left];
```

如果包含重复元素，就可能出现

[1 0 1 1 1]      [1 1 1 0 1]

这两种情况，它们都是数组[0 1 1 1 1]的旋转，而且mid刚好等于1。

// 由于这里是因为mid和最右边的元素比较大小，导致不知道最小的元素实在左半边还是右半边。

因此当mid和最右边元素相等的时候，我们可以直接去掉最右边元素 //

- [x] 154 搜索旋转排序数组中的最小值，有相同元素

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == nums[right]) {
                --right;
            }
            else if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else { // nums[mid] < nums[right] mid也有可能是最小值
                right = mid;
            }
        }
        return nums[left];
    }
};
```



- [x] 33 搜索旋转排序数组，数组中的值互不相同，搜索target

两次二分

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[n - 1]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
    int binarySearch(vector<int>& nums, int left, int right, int target) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left == nums.size() || nums[left] != target ? -1 : left;
    }
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        // 1. 先找到分割点，也即数组中的最小值
        int index = findMin(nums);
        if (target == nums[index]) {
            return index;
        } else if (nums[index] < target && target <= nums[n - 1]) {
            return binarySearch(nums, index, n - 1, target);
        } else {
            return binarySearch(nums, 0, index - 1, target);
        }
    }
};
```



难度升级：一次二分

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        // 一次二分
        int n = nums.size();
        int left = 0, right = n - 1, mid = 0;
        auto check = [&]() -> bool {
            int x = nums[mid];
            /* target在x右边
            如果x在第1段 target在第1段 x < target && target > nums[n - 1]
                        target在第2段 target <= nums[n - 1]
            如果x在第2段 x < target <= nums[n - 1]
            */
            if (x > nums[n - 1]) { 
                return (x < target && target > nums[n - 1]) || target <= nums[n - 1];
            }
            return x < target && target <= nums[n - 1];
        };
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (check()) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left == nums.size() || nums[left] != target ?   -1 : left;
    }
};
```

还挺难绷的。



- [x] 81 搜索旋转排序数组II 数组中的值可能是相同的

```c++
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        // 一次二分
        int n = nums.size();
        int left = 0, right = n - 1;
        auto check = [&](int x) {
            /* target在x右边
            不同段 x在左半段 target在右半段
            x > right && target <= right
            相同段 都在左半段 
            target >= x > right
            都在右半段
            x <= target <= right
            */
            if  (x > nums[right]) { // x在左半段
                return target <= nums[right] || target >= x;
            } else {
                return x <= target && target <= nums[right];
            }
        };
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target || nums[right] == target) 
                return true;
            if (nums[mid] == nums[right]) {
                --right;
            }
            else {
                if (check(nums[mid])) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return left == n || nums[left] != target ? false : true;
    }
};
```

# 12 回溯：矩阵中的路径

需要定义和矩阵大小相等的bool值矩阵，来区分是否已经进入过某个格子。

```c++
class Solution {
public:
    bool backTrack(vector<vector<char>>& matrix, int rows, int columns, int row, int column, string& str, int index, vector<vector<bool>>& visited) {
        if (index == (int)str.size()) {
            return true;
        }
        bool hasPath = false;
        if (row >= 0 && row < rows && column >= 0 && column < columns && str[index] == matrix[row][column] && !visited[row][column]) {
            ++index;
            visited[row][column] = true;
            hasPath = backTrack(matrix, rows, columns, row - 1, column, str, index, visited) ||
                backTrack(matrix, rows, columns, row + 1, column, str, index, visited) ||
                backTrack(matrix, rows, columns, row, column - 1, str, index, visited) ||
                backTrack(matrix, rows, columns, row, column + 1, str, index, visited);
            if (!hasPath) { // 如果hasPath依旧为false，说明当前格子没有正确的路径
                --index;
                visited[row][column] = false;
            }
        }
        return hasPath;
    }
    bool hasPath(vector<vector<char>>& matrix, string &str) {
        if (matrix.empty() || str.empty()) { // 先判断边界问题
            return false;
        }
        int m = matrix.size(), n = matrix[0].size();
        // 由于路径不能重复进入矩阵的个子，所以用bool矩阵标识路径是否已经经过了这个格子
        vector<vector<bool>> visited(m, vector<bool>(n, false)); 
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (backTrack(matrix, m, n, i, j, str, 0, visited)) {
                    return true;
                }
            }
        }
        return false;
    }
};
```

其实这种**回溯**题非常典型，我只是好久没有刷这类型的题目，所以做不出来也很正常。

不过是套路而已。

# 13 回溯：机器人的运动范围

这道题跟上一题非常类似，唯一不同的点在于，它不需要多次遍历找到入口。



起点不固定：单词的第一个字符可能出现在矩阵的任意位置，因此，必须遍历矩阵中所有可能的起点

而机器人的起点是固定的。



# 14 动态规划  + 贪心：剪绳子

**动态规划**

给你一段长度为n的绳子，将其剪成m段，至少剪1段。求得到的最大乘积。

> 思考：假设$f(n)$是长度为$n$的绳子剪成若干段之后的最大乘积，那要给它一剪子，剪出来的长度可以是1...n-1，取最大值，也即$$f(n)=max(i * f(n - i))$$，其中$$0 < i < n$$。这是一个自上而下的递归公式。由于递归会有很多重复的子问题，因此属于动态规划。

**最优子结构**：父问题的最优解依赖于子问题的最优解

**重叠子问题**在求解父问题时，**会反复遇到并计算同一个子问题**



记忆化递归通过缓存子问题结果避免重复计算，属于动态规划的一种实现方式。

自下而上是迭代，自上而下是递归。

用自上而下的递归思路分析问题，写出自下而上的迭代代码。

1. 自下而上的迭代

```c++
class Solution {
public:
    int maxProductAfterCutting(int length) {
        // 剪成m段的最大乘积
       if (length < 2) { // length只能是1或者0，必须砍一刀
           return 0;
       } else if (length == 2) {
           return 1;
       } else if (length == 3) {
           return 2;
       }
       
       int *products = new int[length + 1];
       products[0] = 0; // 无意义
       products[1] = 1; // 作为子段所能提供的最大价值
       products[2] = 2;
       products[3] = 3;
       
       int max = 0;
       for (int i = 4; i <= length; i++) {
           max = 0;
           for (int j = 1; j < i; j++) {
               products[i] = products[j] * products[i - j];
               if (max < products[i]) {
                   max = products[i];
               }
           }
           products[i] = max;
       }
       max = products[length];
       delete[] products;
       return max;
        
    }
};
```

2. 自上而下的递归

```c++
class Solution {
public:
    int maxProductAfterCutting(int length) {
        if (length < 2) { // 必须砍一刀
            return 0;
        } else if (length == 2) {
            return 1;
        } else if (length == 3) {
            return 2;
        }
        vector<int> products(length + 1, -1); // 记忆化搜索
        return maxProductsAfterCutting(products, length);
    }
private:
    int maxProductsAfterCutting(vector<int>&products, int length) {
        if (length <= 3) {
            products[length] = length; // 允许不切割
            return products[length];
        }
        if (products[length] != -1) {
            return products[length];
        }
        int max = 0;
        for (int i = 1; i < length; i++) { 
            products[length] = maxProductsAfterCutting(products, i) * maxProductsAfterCutting(products, length - i); // 上层需基于子问题结果推导最优解，因此递归函数需要返回值
            if (max < products[length]) {
                max = products[length];
            }
            
        }
        products[length] = max;
        return products[length];
    }
};
```

3. 贪心

```c++
class Solution {
public:
    int maxProductAfterCutting(int length) {
        if (length < 2) { // 只能是0或1，必须砍一刀
            return 0;
        } else if (length == 2) {
            return 1;
        } else if (length == 3) {
            return 2;
        } else if (length == 4) {
            return 4;
        }
        // 当n >= 5 时，我们希望尽可能剪出长度为3的绳子 原因是 2*3 > 1*4
        int timesOf3 = length / 3;
        // 当剩余长度为4时，我们希望把绳子剪成 2*2 的两段 原因是 2*2 > 1*3
        if (length - timesOf3 * 3 == 1) {
            timesOf3 -= 1;
        }
        int timesOf2 = (length - timesOf3 * 3) / 2;
        return (int)pow(3, timesOf3) * (int)pow(2, timesOf2);
    }
};
```

，，，怎么会有这种题。



# 15 位运算：二进制中1的个数

Q：什么是异或？

0 ^ 0 = 0

0 ^ 1 = 1

相同为0，相异为1；还可以理解成，**无进位相加**

在C++中，左移是逻辑左移，**高位丢弃，低位补0**

右移要分情况讨论：

对于**有符号数**，高位补**符号位**，低位丢弃，这是算术右移；

对于**无符号数**，高位补0，低位丢弃，这是逻辑右移。





一个整数-1，

如果最后一位是1，最后一位变0，如0011（3）->0010（2）

如果最后一位是0，最右边的1变0，若1后面还有0，则后面的0全都变1，如0100（4）->0011(3)



**如果将一个整数和它-1的结果做位与运算，相当于把最右边的1变成0**，如

0011 & 0010 = 0010

0100 & 0011 = 0000



基于这个思路，可以得到。。。。。。



# 16 数值的整数次方

Q：如何用位运算判断一个数是偶数还是奇数？

如6是偶数，0110；7是奇数，0111；8是偶数，1000；9是奇数，1001；

那么，是不是偶数的最低位都是0，奇数的最低位都是1呢？

```C++
if (num & 0x1 == 1) {
    // 是奇数
}
```

