# 1

# 2

# 3.1 数组中重复的数字

**2025-10-10**

方法1：排序。找到重复的数只需要从前往后遍历。时间复杂度:$O(nlogn)$

方法2：哈希表。遍历数组，用哈希表记录遍历过的元素。时间复杂度:$O(n)$，空间复杂度:$O(n)$

方法3：**所有数字都在0~n-1的范围内**，如果数组中没有重复的数字，那么对数组进行排序后数字i应该出现在下标为i的位置上。

```c++
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            if (nums[i] < 0 || nums[i] >= n) {
                return -1;
            }
        }
        for (int i = 0; i < n; ++i) {
            while (nums[i] != i) {
                if (nums[i] == nums[nums[i]]) { // 有重复元素
                    return nums[i];
                } else {
                    swap(nums[i], nums[nums[i]]);
                }
            }
        }
        return -1;
    }
};
```

Q1:为什么`while`不会死循环？

数组中要么有重复的元素，要么没有重复的元素。

如果没有重复的元素，例如[1, 0]，每次交换都会让1个元素归位，循环会结束；

如果有重复的元素，例如[1, 1]，会直接return

时间复杂度:$O(n)$

空间复杂度:$O(1)$



# 3.2 不修改数组找出重复的数

**2025-10-13**

思考：要求不能修改输入的数组，方法一和方法三可以拷贝一个临时的数组，但是如果希望空间复杂度是$O(1)$的呢？



题目要求在一个长度为$n+1$的数组里的所有数字都在1~n的范围内，所以至少有1个数是重复的。

我们把1~n从中对半分，分为[1, m]和[m + 1， n]，如果[1, m]的个数$>m$，说明这其中有重复的元素。

持续二分。



二分查找，以左闭右闭区间为例

```c++
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n = nums.size();
        int left = 1, right = n - 1; // 数字范围 1~n-1

        while (left <= right) {
            int m = left + (right - left) / 2;
            int cnt = 0;
            for (int x : nums) {
                if (x >= left && x <= m) {
                    ++cnt;
                }
                if (cnt > (m - left + 1)) {
                    break;
                }
            }
            if (cnt > (m - left + 1)) {
                right = m - 1;
            } else {
                left = m + 1;
            }
        }
        return left; // left就是重复数字
    }
};

```

时间复杂度：$O(nlogn)$

空间复杂度：$O(1)$

注意：

1. 左闭右闭区间的长度。如$[1, 2, 3]$，$len = 3 - 1 + 1 = 3$。也即 $len = right - left + 1$

2. 为什么当 $cnt > m - left + 1$ 之后 $right = m - 1$ ？

   从直觉上来看，区间被 $m$ 划分为 $[left, m]$ 和 $[m + 1, right]$，那么如果 $cnt > m - left + 1$，$right$ 右端点应该收缩到 $m$ 才对。但是这样是不对的。例如 $[1, 1]$的话，$left$ 指向 0 时，$right$ 也指向 0 时，$m = 0$，接着 $cnt$ 计算 1的个数，就会触发 $right = m$，就变成死循环了。

   因此，在**左闭右闭区间**中，无论是 $left$ 还是 $right$ 都要变，进而收缩 [$left$, $right$] 合法区间。

   那么这里为什么 $right = m - 1$ 一定是对的呢？

   - 如果 m 是重复的元素，那么在 [left, m - 1]中一定还有m，所以没问题；
   - 如果 m 不是重复的元素，那么 [left, m - 1]中一定还存在着重复的元素，所以也没问题；

   综上，收缩 $right$，重复的元素仍然在合法的区间中。

3. 最后，为什么返回值是 $left$ ？

   每次迭代结束后，重复元素一定在 $[left, right]$ 中。

   而当整个循环结束后，$left = right + 1$。此时的合法区间是 $[right + 1, left]$。

   因此，重复的数字便是 $left$。



该算法只能找出一个重复的元素，那么如果要让你找出数组中所有重复的元素应该如何做呢？

$Leecode$ 442 数据中重复的元素



# 4 二维数组中的二分查找

// 从左下角开始查找，当然，从右上角查找也是可以的。

```c++
class Solution {
public:
    bool searchArray(vector<vector<int>> array, int target) {
        if (array.empty()) 
            return false;
        int rows = array.size(), columns = array[0].size();
        int row = array.size() - 1, column = 0;
        bool found = false;
        while (row >= 0 && column < columns) {
            if (array[row][column] == target) {
                found = true;
                break;
            } else if (array[row][column] < target) {
                ++column;
            } else if (array[row][column] > target) {
                --row;
            }
        }
        return found;
        
    }
};
```



# 5 替换空格

```c++
class Solution {
public:
    string replaceSpaces(string &str) {
        int n = str.size();
        string res {};
        for (int i = 0; i < n; ++i) {
            if (str[i] == ' ') {
                res += "%20";
            } else {
                res += str[i];
            }
        }
        return res; // o(n) o(n)
    }
};
```

时间复杂度：$O(n)$

空间复杂度：$O(n)$



正确做法：在原来的字符串上进行双指针

先计算空格的个数，得到新的字符串长度，然后从后往前遍历。其实这个方法是挺好的，就是我咋感觉它这个代码不太简介，尽管变量名见名知意。

```c++
class Solution {
public:
    string replaceSpaces(string &str) {
        int n = str.size();
        // 1. 计算空格的个数
        int numberOfBlank = 0;
        for (int i = 0; i < n; ++i) {
            if (str[i] == ' ') {
                ++numberOfBlank;
            }
        }
        // 2. 得到扩展之后字符串的长度
        int newLength = n + 2 * numberOfBlank;
        str.resize(newLength);
        // 3. 双指针
        int indexOfOriginal = n - 1, indexOfNew = newLength - 1;
        while (indexOfOriginal != indexOfNew) {
            if (str[indexOfOriginal] == ' ') {
                str[indexOfNew--] = '0';
                str[indexOfNew--] = '2';
                str[indexOfNew--] = '%';
            } else {
                str[indexOfNew--] = str[indexOfOriginal];
            }
            --indexOfOriginal;
        }
        return str;
    }
};
```



# 6 链表：从尾到头打印链表

定义一个链表结构体

```c++
struct ListNode {
    int m_nValue;
    ListNode* pNext;
};
```

不修改原结构，用栈；修改原结构，就相当于反转链表



如果用栈实现的话，我们应该联想到**递归**，因为递归本身也是一个栈结构。

注意：与栈相比，如果链表长度很长，会导致栈溢出。



# 关于树的一些问题

前序遍历

中序遍历

后序遍历

递归 + 迭代，拢共6种实现方法，要搞清楚(dfs)

广度优先遍历（bfs) 为啥叫bfs?



堆（最大堆 和 最小堆） 和 红黑树



# 7 重建二叉树

二叉树节点的定义

```c++
struct BinaryTreeNode {
    int m_nVaue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
}
```

# 8 二叉树的下一个节点

分析：对于一棵二叉树，要找出其中序遍历的下一个节点。

如果当前节点有右子树，那么它的下一个节点就是从右子树的父节点出发，一直`dfs`找到最深的左子节点；

如果当前节点没有右子树，

- 如果它是某个父节点的左子节点，那么它的下一个节点就是该父节点；

```plaintext
	爸爸
   /
我（没有右子树）
```

- 如果它是某个父节点的右子节点，那么就需要沿着父节点回溯，直到找到一个是它**父节点的左子节点的节点**。如果这样的节点存在，那么下一个节点就是父节点。

```plaintext
    爷爷
   /
爸爸
   \
   我（没有右子树）
```

综上所述，如果没有右子树，那么就是**找第一个把当前节点包含在左子树的祖先**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode *father;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* p) {
        if (p == nullptr) {
            return nullptr;
        }
        TreeNode* nextNode = nullptr;
        if (p->right != nullptr) { // 如果有右子树
            TreeNode* pRight = p->right;
            while (pRight->left != nullptr) {
                pRight = pRight->left;
            }
            nextNode = pRight;
        } else if (p->father != nullptr) { // 如果没有右子树
            TreeNode* pCurrent = p;
            TreeNode* pFather = p->father;
            while (pFather != nullptr && pFather->right == pCurrent) {
                pCurrent = pFather;  // 若当前节点是父节点的右子节点，继续向上
                pFather = pCurrent->father;
            }
            nextNode = pFather; // 退出循环时，father要么是nullptr，要么pCurrent == father->left
        }
        return nextNode;
        
    }
};
```

