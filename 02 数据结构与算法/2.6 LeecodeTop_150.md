# 股票问题

## Leecode 122 买卖股票的最佳时机 I

![image-20251110200747264](E:\Note\02 数据结构与算法\2.6 LeecodeTop_150.assets\image-20251110200747264.png)



## 买卖股票的最佳时机 II

在每一天你可以选择买入/卖出股票，每天结束最多允许持有1股，返回你能得到的最大利润。



解题：

定义 $dp(i, 0)$ 表示**第 i 天结束** 未持有股票时的最大利润。

定义 $dp(i, 1)$ 表示**第 i 天结束** 持有股票时的最大利润。

递归 超时

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        return dfs(prices, n - 1, false); // 最后一天，一定不会持有股票
    }
    int dfs(vector<int>& prices, int i, bool flag) {
        if (i == -1) {
            return flag == true ? -INT_MAX / 2: 0;
        }
        /*
        if (i == 0) {
            return flag == true ? -prices[0]: 0; // 递归边界，这里需要保证prices数组不是空的
        }
        */
        int max_profit = 0;
        if (flag) { // 第 i 天结束时，持有股票
            max_profit = max({max_profit, dfs(prices, i - 1, false) - prices[i], dfs(prices, i - 1, true)});
        } else {
            max_profit = max({max_profit, dfs(prices, i - 1, false), dfs(prices, i - 1, true) + prices[i]});
        }
        return max_profit;
    }
};

// 时间复杂度 O(2^n)
// 空间复杂度 O(n)的递归调用栈
```

记忆化搜索 有待进一步完善

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<array<int, 2>> dp(n + 1, {-1, -1}); // -1 没计算过
        return dfs(prices, n, 0，dp); // 最后一天，一定不会持有股票
    }
    int dfs(vector<int>& prices, int i, int hold, vector<vector<int>>& dp) {
        if (i == 0) {
            return flag == true ? -INT_MAX / 2: 0;
        }
        /*
        if (i == 0) {
            return flag == true ? -prices[0]: 0; // 递归边界，这里需要保证prices数组不是空的
        }
        */
        int& ret = dp[i][hold];
       	if (ret != -1) {
            return ret;
        }
        if (hold) { // 第 i 天结束时，持有股票
            ret = max({ret, dfs(prices, i - 1, 0, dp) - prices[i], dfs(prices, i - 1, 1, dp)});
        } else {
            ret = max({ret, dfs(prices, i - 1, 0, dp), dfs(prices, i - 1, 1, dp) + prices[i]});
        }
        return ret;
    }
};

// 时间复杂度 O(2^n)
// 空间复杂度 O(n)的递归调用栈
```



# 

## 跳跃游戏

这道题考察的是 动态规划？回溯？

想岔了，这题的思路是遍历数组，维护当前所能到达的最远位置。:sob:



跳跃游戏II 写不出来 想死

现在真的是刷题刷少了，手生了。
